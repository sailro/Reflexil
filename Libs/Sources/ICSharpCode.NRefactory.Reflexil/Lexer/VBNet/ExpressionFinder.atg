using System;
using System.Collections;
using System.Collections.Generic;

PUSHCOMPILER WITH EXPECTEDSETS ExpressionFinder

/* START AUTOGENERATED TOKENS SECTION */
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	EOL
	ident
	LiteralString
	LiteralCharacter
	LiteralInteger
	LiteralDouble
	LiteralSingle
	LiteralDecimal
	LiteralDate
	XmlOpenTag
	XmlCloseTag
	XmlStartInlineVB
	XmlEndInlineVB
	XmlCloseTagEmptyElement
	XmlOpenEndTag
	XmlContent
	XmlComment
	XmlCData
	XmlProcessingInstruction

	/* ----- special character ----- */
	"="
	":"
	","
	"&"
	"/"
	"\\"
	"."
	"..."
	".@"
	"!"
	"-"
	"+"
	"^"
	"?"
	"*"
	"{"
	"}"
	"("
	")"
	">"
	"<"
	"<>"
	">="
	"<="
	"<<"
	">>"
	"+="
	"^="
	"-="
	"*="
	"/="
	"\\="
	"<<="
	">>="
	"&="
	":="

	/* ----- keywords ----- */
	"AddHandler"
	"AddressOf"
	"Aggregate"
	"Alias"
	"And"
	"AndAlso"
	"Ansi"
	"As"
	"Ascending"
	"Assembly"
	"Auto"
	"Binary"
	"Boolean"
	"ByRef"
	"By"
	"Byte"
	"ByVal"
	"Call"
	"Case"
	"Catch"
	"CBool"
	"CByte"
	"CChar"
	"CDate"
	"CDbl"
	"CDec"
	"Char"
	"CInt"
	"Class"
	"CLng"
	"CObj"
	"Compare"
	"Const"
	"Continue"
	"CSByte"
	"CShort"
	"CSng"
	"CStr"
	"CType"
	"CUInt"
	"CULng"
	"CUShort"
	"Custom"
	"Date"
	"Decimal"
	"Declare"
	"Default"
	"Delegate"
	"Descending"
	"Dim"
	"DirectCast"
	"Distinct"
	"Do"
	"Double"
	"Each"
	"Else"
	"ElseIf"
	"End"
	"EndIf"
	"Enum"
	"Equals"
	"Erase"
	"Error"
	"Event"
	"Exit"
	"Explicit"
	"False"
	"Finally"
	"For"
	"Friend"
	"From"
	"Function"
	"Get"
	"GetType"
	"Global"
	"GoSub"
	"GoTo"
	"Group"
	"Handles"
	"If"
	"Implements"
	"Imports"
	"In"
	"Infer"
	"Inherits"
	"Integer"
	"Interface"
	"Into"
	"Is"
	"IsNot"
	"Join"
	"Key"
	"Let"
	"Lib"
	"Like"
	"Long"
	"Loop"
	"Me"
	"Mod"
	"Module"
	"MustInherit"
	"MustOverride"
	"MyBase"
	"MyClass"
	"Namespace"
	"Narrowing"
	"New"
	"Next"
	"Not"
	"Nothing"
	"NotInheritable"
	"NotOverridable"
	"Object"
	"Of"
	"Off"
	"On"
	"Operator"
	"Option"
	"Optional"
	"Or"
	"Order"
	"OrElse"
	"Out"
	"Overloads"
	"Overridable"
	"Overrides"
	"ParamArray"
	"Partial"
	"Preserve"
	"Private"
	"Property"
	"Protected"
	"Public"
	"RaiseEvent"
	"ReadOnly"
	"ReDim"
	"Rem"
	"RemoveHandler"
	"Resume"
	"Return"
	"SByte"
	"Select"
	"Set"
	"Shadows"
	"Shared"
	"Short"
	"Single"
	"Skip"
	"Static"
	"Step"
	"Stop"
	"Strict"
	"String"
	"Structure"
	"Sub"
	"SyncLock"
	"Take"
	"Text"
	"Then"
	"Throw"
	"To"
	"True"
	"Try"
	"TryCast"
	"TypeOf"
	"UInteger"
	"ULong"
	"Unicode"
	"Until"
	"UShort"
	"Using"
	"Variant"
	"Wend"
	"When"
	"Where"
	"While"
	"Widening"
	"With"
	"WithEvents"
	"WriteOnly"
	"Xor"
	"GetXmlNamespace"
/* END AUTOGENERATED TOKENS SECTION */

PRODUCTIONS
/*------------------------------------------------------------------------*/
ExpressionFinder =
	(. PushContext(Context.Global, la, t); .)
	{ OptionStatement }
	{ ImportsStatement }
	{ EXPECTEDCONFLICT("<") AttributeBlock } /* Expected LL(1) conflict: we can't tell global attributes */
	                                         /* from those on types. */
	                                         /* This isn't a problem, we can just treat all as global attributes */
	{ NamespaceMemberDeclaration }
	(. PopContext(); .)
.

StatementTerminator
	(. if (la != null) CurrentBlock.lastExpressionStart = la.Location; .)
=
	EOL | ":"
.

OptionStatement = 
	"Option" ( ( "Explicit" | "Strict" | "Infer" ) [ "Off" | "On" ] | "Compare" ( "Text" | "Binary" ) )  StatementTerminator
.

ImportsStatement =
	"Imports" (. PushContext(Context.Importable, la, t); .)
	(. nextTokenIsStartOfImportsOrAccessExpression = true;	.)
	(
		( "Global" | Identifier | PrimitiveTypeName ) { TypeSuffix } [ ( "." | "=" ) TypeName ]
		| XmlOpenTag Identifier "=" LiteralString XmlCloseTag
	)
	(. PopContext(); .)
	StatementTerminator

.

AttributeBlock =
	"<" (. wasNormalAttribute = true; PushContext(Context.Attribute, la, t); .) [ ( "Assembly" | "Module" ) ":" (. wasNormalAttribute = false; .) ] { ANY } ">" (. PopContext(); .) [ EOL ]
.

NamespaceMemberDeclaration =
	NamespaceDeclaration
	| TypeDeclaration
.

NamespaceDeclaration =
	"Namespace" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) { ANY } (. PopContext(); .) StatementTerminator
	{ NamespaceMemberDeclaration }
	"End" "Namespace" StatementTerminator
.

TypeDeclaration =
	{ AttributeBlock }
	{ TypeModifier }
	( ClassOrModuleOrStructureTypeDeclaration |
	DelegateTypeDeclaration |
	EnumTypeDeclaration |
	InterfaceDeclaration )
.

ClassOrModuleOrStructureTypeDeclaration =
	(. PushContext(Context.TypeDeclaration, la, t); .)
	( "Module" | "Class" | "Structure" ) (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "(" "Of" GenericTypeParameterDeclaration ")" ] StatementTerminator
	[ (. isMissingModifier = false; .) "Inherits" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) StatementTerminator ]
	[ (. isMissingModifier = false; .) "Implements" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) { "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) } StatementTerminator ]
	{
		{ AttributeBlock } (.OnEachPossiblePath: isMissingModifier = true; .)
		{ TypeOrMemberModifier (. isMissingModifier = false; .) } (. isMissingModifier = false; .)
		( ClassOrModuleOrStructureTypeDeclaration | DelegateTypeDeclaration | EnumTypeDeclaration
		| InterfaceDeclaration | MemberDeclaration )
	}
	(. isMissingModifier = false; .)
	"End" ( "Module" | "Class" | "Structure" ) StatementTerminator
	(. PopContext(); .)
.

EnumTypeDeclaration =
	(. PushContext(Context.TypeDeclaration, la, t); .)
	"Enum" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ] StatementTerminator
	{
		{ AttributeBlock }
		(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
		[ "=" Expression ]
		StatementTerminator
	}
	"End" "Enum" StatementTerminator
	(. PopContext(); .)
.

InterfaceDeclaration =
	(. PushContext(Context.TypeDeclaration, la, t); .)
	"Interface" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "(" "Of" GenericTypeParameterDeclaration ")" ] StatementTerminator
	[ "Inherits" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) { "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) } StatementTerminator ]
	{
		{ AttributeBlock } (.OnEachPossiblePath: isMissingModifier = true; .)
		{ TypeOrMemberModifier (. isMissingModifier = false; .) } (. isMissingModifier = false; .)
		( ClassOrModuleOrStructureTypeDeclaration | DelegateTypeDeclaration | EnumTypeDeclaration
		| InterfaceDeclaration | InterfaceMemberDeclaration )
	}
	(. isMissingModifier = false; .)
	"End" "Interface" StatementTerminator
	(. PopContext(); .)
.

InterfaceMemberDeclaration =
	InterfaceEvent | InterfaceProperty | InterfaceSubOrFunction
.

TypeOrMemberModifier =
	MemberModifier /* contains all modifiers for types */
.

InterfaceEvent =
	"Event" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) | "(" [ ParameterList ] ")" ]
	StatementTerminator
.

InterfaceProperty =
	"Property" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "(" [ ParameterList ] ")" ] [ "As" (. PushContext(Context.Type, la, t); .) { AttributeBlock } TypeName (. PopContext(); .) ]
	StatementTerminator
.

InterfaceSubOrFunction =
	("Sub" | "Function")
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) ANY (. PopContext(); .)
	{ "(" [ ( "Of" GenericTypeParameterDeclaration | ParameterList ) ] ")" }
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	StatementTerminator
.

GenericConstraint =
	TypeName | "New" | "Class" | "Structure"
.

GenericConstraintList =
	GenericConstraint | "{" GenericConstraint { "," GenericConstraint } "}"
.

GenericTypeParameterDeclaration =
 	[ "Out" | "In" ] (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) IdentifierExceptOut (. PopContext(); .) [ "As" (. PushContext(Context.Type, la, t); .) GenericConstraintList (. PopContext(); .) ]
	{ "," [ "Out" | "In" ] (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) IdentifierExceptOut (. PopContext(); .) [ "As" (. PushContext(Context.Type, la, t); .) GenericConstraintList (. PopContext(); .) ] }
.

DelegateTypeDeclaration =
	"Delegate" ("Sub" | "Function")
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) ANY (. PopContext(); .)
	{ "(" [ "Of" GenericTypeParameterDeclaration | ParameterList ] ")" }
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	StatementTerminator
.

MemberDeclaration =
	(. PushContext(Context.Member, la, t); .)
	(
		MemberVariableOrConstantDeclaration |
		SubOrFunctionDeclaration |
		ExternalMemberDeclaration |
		EventMemberDeclaration |
		CustomEventMemberDeclaration |
		PropertyDeclaration |
		OperatorDeclaration
	) 
	(. PopContext(); .)
.

SubOrFunctionDeclaration = 
	("Sub" | "Function")
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) ANY (. PopContext(); .)
	{ "(" [ ( "Of" GenericTypeParameterDeclaration | ParameterList ) ] ")" }
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	[ ( "Implements" | "Handles" ) [ ( "Me" | "MyClass" | "MyBase" ) "." ] TypeName ]
	StatementTerminatorAndBlock
	"End" ("Sub" | "Function") StatementTerminator
.

ExternalMemberDeclaration =
	"Declare" [ "Ansi" | "Unicode" | "Auto" ] ( "Sub" | "Function" )
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	"Lib" LiteralString
	[ "Alias" LiteralString ]
	[ "(" [ ParameterList ] ")" ]
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	StatementTerminator
.

EventMemberDeclaration =
	"Event"
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	( "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) | [ "(" [ ParameterList ] ")" ] )
	[ "Implements" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) /*"." IdentifierOrKeyword*/
	  { "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) /*"." IdentifierOrKeyword*/ } ]
	/* the TypeName production already allows the "." IdentifierOrKeyword syntax, so to avoid an ambiguous grammer we just leave that out */
	StatementTerminator
.

CustomEventMemberDeclaration =
	"Custom" EventMemberDeclaration
	{
		{ AttributeBlock } ( "AddHandler" | "RemoveHandler" | "RaiseEvent" ) "(" ParameterList ")"
		StatementTerminatorAndBlock
		"End" ( "AddHandler" | "RemoveHandler" | "RaiseEvent" ) StatementTerminator
	}
	"End" "Event" StatementTerminator
.

PropertyDeclaration =
	"Property"
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "(" [ ParameterList ] ")" ]
	[ "As"  { AttributeBlock } ( NewExpression | (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ) ]
	[ "Implements" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) /*"." IdentifierOrKeyword*/
	    { "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) /*"." IdentifierOrKeyword*/ } ]
	[ "=" Expression ] StatementTerminator
	(. PopContext(); .) { EXPECTEDCONFLICT("<") AttributeBlock }
	{ EXPECTEDCONFLICT("Public", "Protected", "Private", "Friend") AccessModifier
	// HACK : OnEachPossiblePath cannot detect that this might be the end of an auto property
	//        so we need to simulate it
	(.OnEachPossiblePath: SetIdentifierExpected(la); .) }
	[ (. PushContext(Context.Member, la, t); .)
	( "Get" | "Set" ) [ "(" [ ParameterList ] ")" ]
		StatementTerminatorAndBlock
		"End" ( "Get" | "Set" ) StatementTerminator
	[ { AttributeBlock } { AccessModifier } ( "Get" | "Set" ) [ "(" [ ParameterList ] ")" ]
		StatementTerminatorAndBlock
		"End" ( "Get" | "Set" ) StatementTerminator ]
	
	"End" "Property" StatementTerminator ]
.

OperatorDeclaration =
	"Operator" (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) ANY (. PopContext(); .)
	"(" ParameterList ")"
	[ "As" (. PushContext(Context.Type, la, t); .) { AttributeBlock } TypeName (. PopContext(); .) ]
	StatementTerminatorAndBlock
	"End" "Operator" StatementTerminator
.

MemberVariableOrConstantDeclaration =
	MemberVariableOrConstantDeclarator { "," MemberVariableOrConstantDeclarator } StatementTerminator
.

MemberVariableOrConstantDeclarator =
	[ "Const" ]
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) IdentifierForFieldDeclaration (. PopContext(); .)
	[ "?" ] { "(" [ Expression ] { "," [ Expression ] } ")" }
	[ "As" (. PushContext(Context.Type, la, t); .) ( NewExpression | TypeName ) (. PopContext(); .) ]
	[ "=" Expression ]
.

ParameterList =
	Parameter { "," Parameter }
.

Parameter =
	(. PushContext(Context.Parameter, la, t); .)
	{ AttributeBlock } { ParameterModifier }
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	[ "=" Expression ]
	(. PopContext(); .)
.

StatementTerminatorAndBlock =
	(. PushContext(Context.Body, la, t); .)
	StatementTerminator
	{ EXPECTEDCONFLICT("End")
		(
			[ Statement] StatementTerminator
		|	"End"
			( StatementTerminator /* End+StatementTerminator is end statement */
			| /* End+anything else is the end of this block. */
			  (.
				currentState = endOfStatementTerminatorAndBlock; /* leave this block */
				InformToken(t); /* process End again*/
				/* for processing current token (la): go to the position after processing End */
				goto switchlbl;
			  .)
			  ANY /* never reached due to goto above: */
			      /* this ANY is just so that Coco knows this branch isn't empty */
			)
		)
	}
	(.NamedState:endOfStatementTerminatorAndBlock.)
	(. PopContext(); .)
.

Expression
	(.NamedState:startOfExpression.)
=
	(. PushContext(Context.Expression, la, t); .)
	SimpleExpressionWithSuffix { BinaryOperator SimpleExpressionWithSuffix }
	(. PopContext(); .)
.

BinaryOperator =
	"+" | "-" | "*" | "\\" | "/" | "^" | "Mod"
	| "=" | "<>" | "<" | ">" (. wasNormalAttribute = false; .) | "<=" | ">=" 
	| "Like" | "&" | "And" | "AndAlso" | "Or" | "OrElse"
	| "Xor" | "<<" | ">>" | "Is" | "IsNot"
	| "^=" | "*=" | "/=" | "\\=" | "+=" | "-=" | "&=" | "<<=" | ">>=" | "To" | ":="
.

UnaryOperator =
	"+" | "-" | "Not" | "AddressOf"
.

SimpleExpressionWithSuffix =
	(. PushContext(Context.Expression, la, t); .)
	{ UnaryOperator }
	(
		SimpleExpression { ExpressionSuffix }
		| "TypeOf" SimpleExpressionWithSuffix "Is" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .)
		| NewExpression
		| CollectionInitializer
	)
	(. PopContext(); .)
.

SimpleExpression =
	(. PushContext(Context.Expression, la, t); .)
    (    Literal
    |    ( "(" (. activeArgument = 0; .) Expression // HACK in ExpressionRangeVariable Identifier is consumed before start
    													// of Expression so this can be an argument list too
    		{ "," (. activeArgument++; .) Expression } ")" )
    |    IdentifierForExpressionStart
    |    PrimitiveTypeName
    |    ( "." | "!" | ".@" | "..." ) (. nextTokenIsStartOfImportsOrAccessExpression = true; wasQualifierTokenAtStart = true; .) [ XmlOpenTag ] IdentifierOrKeyword [ XmlCloseTag ]
    |    "GetType" "(" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ")"
    |    "GetXmlNamespace" "(" (. readXmlIdentifier = true; .) Identifier ")"
    |    XmlLiteral
    |    LambdaExpression
    |    GREEDY QueryExpression
    |    CastExpression
    |    ConditionalExpression
    )
	(. PopContext(); .)
.

NewExpression =
	"New" (. PushContext(Context.ObjectCreation, la, t); .)
	(
		TypeName
		[
			EXPECTEDCONFLICT("From")
			(
				(. PushContext(Context.CollectionInitializer, la, t); .)
				"From"
				(
					CollectionInitializer /* From + CollectionInitializer is a NewExpression */
				|
					(.
						currentState = endOfStatementTerminatorAndBlock; /* leave this block */
						InformToken(t); /* process From again*/
						/* for processing current token (la): go to the position after processing End */
						goto switchlbl;
					.)
					ANY /* never reached due to goto above: */
					/* this ANY is just so that Coco knows this branch isn't empty */
				)
				(. PopContext(); .)
			|
				/* handle array initializer after New */
				(. PushContext(Context.CollectionInitializer, la, t); .)
				CollectionInitializer
				(. PopContext(); .)
			|
				(. PushContext(Context.ObjectInitializer, la, t); .)
				"With" ObjectInitializer
				(. PopContext(); .)
			)
		]
	|
		(. PushContext(Context.ObjectInitializer, la, t); .)
		"With" ObjectInitializer
		(. PopContext(); .)
	)
	(. PopContext(); .)
.

ObjectInitializer =
	"{" [ [ "Key" ] "." IdentifierOrKeyword "=" Expression { "," [ "Key" ] "." IdentifierOrKeyword "=" Expression } ] "}"
.

CollectionInitializer =
	"{" [ Expression { "," Expression } ] "}"
.

ExpressionSuffix =
    "(" (. PushContext(Context.Expression, la, t); .)
        ( "Of" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .)
            { "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) }
    |  [ ArgumentList ] ) (. PopContext(); .) ")"
|    ( "." | "!" | ".@" | "..." ) (. nextTokenIsStartOfImportsOrAccessExpression = true; .) [ XmlOpenTag ] IdentifierOrKeyword [ XmlCloseTag ]
.

CastExpression =
	SimpleCastExpression | ("DirectCast" | "TryCast" | "CType") "(" Expression "," (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ")"
.

SimpleCastExpression =
	(
		"CBool"   |
		"CByte"   |
		"CChar"   |
		"CDate"   |
		"CDec"    |
		"CDbl"    |
		"CInt"    |
		"CLng"    |
		"CObj"    |
		"CSByte"  |
		"CShort"  |
		"CSng"    |
		"CStr"    |
		"CUInt"   |
		"CULng"   |
		"CUShort"
	)
	"(" Expression ")"
.

ConditionalExpression =
	"If" "(" Expression "," Expression [ "," Expression ] ")"
.

LambdaExpression =
	SubLambdaExpression |
	FunctionLambdaExpression
.

SubLambdaExpression =
	"Sub" "(" [ ParameterList ] ")"
	( GREEDY Statement | StatementTerminatorAndBlock "End" "Sub" )
.

FunctionLambdaExpression =
	"Function" "(" [ ParameterList ] ")"
	( GREEDY Expression | [ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ] StatementTerminatorAndBlock "End" "Function" )
.

QueryExpression
	(. PushContext(Context.Query, la, t); .)
=
	( FromQueryOperator | AggregateQueryOperator )
	{ QueryOperator }
	(. PopContext(); .)
.
 
QueryOperator =
	FromQueryOperator
	| AggregateQueryOperator
	| SelectQueryOperator
	| DistinctQueryOperator
	| WhereQueryOperator
	| OrderByQueryOperator
	| PartitionQueryOperator
	| LetQueryOperator
	| GroupByOrGroupJoinQueryOperator
	| JoinQueryOperator 
.

FromQueryOperator =
	"From" CollectionRangeVariable { "," CollectionRangeVariable }
.

AggregateQueryOperator =
	"Aggregate" CollectionRangeVariable { QueryOperator } "Into" ExpressionRangeVariable { "," ExpressionRangeVariable }
.

SelectQueryOperator =
	"Select" ExpressionRangeVariable { "," ExpressionRangeVariable }
.

DistinctQueryOperator =
	"Distinct"
.

WhereQueryOperator =
	"Where" Expression
.

OrderByQueryOperator =
	"Order" "By" Expression ( "Ascending" | "Descending" ) { "," Expression ( "Ascending" | "Descending" ) }
.

PartitionQueryOperator =
	( "Take" | "Skip" ) [ "While" ] Expression
.

LetQueryOperator =
	"Let" ExpressionRangeVariable { "," ExpressionRangeVariable }
.

GroupByOrGroupJoinQueryOperator =
	"Group"
	(
		EXPECTEDCONFLICT("Join")
		JoinQueryOperator { ( "Group"  JoinQueryOperator GroupJoinSuffix | JoinQueryOperator ) }
		GroupJoinSuffix
	|
		( EXPECTEDCONFLICT("By") () | ExpressionRangeVariable { "," ExpressionRangeVariable } )
		"By" ExpressionRangeVariable { "," ExpressionRangeVariable }
		"Into" ExpressionRangeVariable { "," ExpressionRangeVariable }
	)
.

JoinQueryOperator =
	"Join" CollectionRangeVariable
	"On" Expression "Equals" Expression { "," Expression "Equals" Expression }
.

GroupJoinSuffix =
	"Into" ExpressionRangeVariable { "," ExpressionRangeVariable }
.

ExpressionRangeVariable =
	[
		EXPECTEDCONFLICT("Where", "Until", "Unicode", "Text", "Take", "Skip", "Preserve",
						  "Order", "Off", "Out", "Key", "Join", "Into", "Infer", "Group", "From",
						  "Explicit", "Equals", "Distinct", "Descending", "Compare", "By",
						  "Binary", "Auto", "Assembly", "Ascending", "Ansi", "Aggregate", ident)
		(
			(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier
			// HACK: needs to be optional because Expression can start with Identifier too
			[  (. PopContext(); isAlreadyInExpr = true; .)
				( "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) "="
				| "="
				| (.
					currentState = endOfStatementTerminatorAndBlock; /* leave this block */
					InformToken(t); /* process Identifier again*/
					/* for processing current token (la): go to the position after processing End */
					goto switchlbl;
				.)
				ANY /* never reached due to goto above: */
				/* this ANY is just so that Coco knows this branch isn't empty */
				)
			]
		)
	]
	Expression
	(. if (!isAlreadyInExpr) PopContext(); isAlreadyInExpr = false; .)
.

CollectionRangeVariable =
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
	"In" Expression
.

/* semantic action will be inserted on all paths that possibly lead to XmlLiteral */
XmlLiteral
    (.OnEachPossiblePath: nextTokenIsPotentialStartOfExpression = true; .)
=
    (. PushContext(Context.Xml, la, t); .)
    (
    	( XmlComment | XmlProcessingInstruction | XmlCData ) [ XmlContent ] { ( XmlComment | XmlProcessingInstruction ) [ XmlContent ] } [ XmlElement { XmlComment [ XmlContent ] } ]
    |
    	XmlElement { XmlComment [ XmlContent ] }
    )
    (. PopContext(); .)
.

XmlElement =
	(. PushContext(Context.Xml, la, t); .)
	XmlOpenTag { ANY | XmlEmbeddedExpression } ( XmlCloseTagEmptyElement | XmlCloseTag { ANY | XmlEmbeddedExpression | XmlElement } XmlOpenEndTag { ANY | XmlEmbeddedExpression } XmlCloseTag )
	(. PopContext(); .)
.

XmlEmbeddedExpression =
	XmlStartInlineVB Expression XmlEndInlineVB
.

PrimitiveTypeName = 
	"Byte" |
    "SByte" |
    "UShort" |
    "Short" |
    "UInteger" |
    "Integer" |
    "ULong" |
    "Long" |
	"Single" |
	"Double" |
	"Decimal" |
	"Boolean" |
	"Date" |
	"Char" |
	"String" |
	"Object"
.
	
TypeName = ( "Global" | Identifier | PrimitiveTypeName | "?" /* used for ? = completion */ ) { TypeSuffix } { "." IdentifierOrKeyword { TypeSuffix } } .

TypeSuffix = "(" ( "Of" [ TypeName ] { "," [ TypeName ] } | [ ArgumentList ] ) ")" .

IdentifierOrKeyword = ident
| "AddHandler"
| "AddressOf"
| "Aggregate"
| "Alias"
| "And"
| "AndAlso"
| "Ansi"
| "As"
| "Ascending"
| "Assembly"
| "Auto"
| "Binary"
| "Boolean"
| "ByRef"
| "By"
| "Byte"
| "ByVal"
| "Call"
| "Case"
| "Catch"
| "CBool"
| "CByte"
| "CChar"
| "CDate"
| "CDbl"
| "CDec"
| "Char"
| "CInt"
| "Class"
| "CLng"
| "CObj"
| "Compare"
| "Const"
| "Continue"
| "CSByte"
| "CShort"
| "CSng"
| "CStr"
| "CType"
| "CUInt"
| "CULng"
| "CUShort"
| "Custom"
| "Date"
| "Decimal"
| "Declare"
| "Default"
| "Delegate"
| "Descending"
| "Dim"
| "DirectCast"
| "Distinct"
| "Do"
| "Double"
| "Each"
| "Else"
| "ElseIf"
| "End"
| "EndIf"
| "Enum"
| "Equals"
| "Erase"
| "Error"
| "Event"
| "Exit"
| "Explicit"
| "False"
| "Finally"
| "For"
| "Friend"
| "From"
| "Function"
| "Get"
| "GetType"
| "Global"
| "GoSub"
| "GoTo"
| "Group"
| "Handles"
| "If"
| "Implements"
| "Imports"
| "In"
| "Infer"
| "Inherits"
| "Integer"
| "Interface"
| "Into"
| "Is"
| "IsNot"
| "Join"
| "Key"
| "Let"
| "Lib"
| "Like"
| "Long"
| "Loop"
| "Me"
| "Mod"
| "Module"
| "MustInherit"
| "MustOverride"
| "MyBase"
| "MyClass"
| "Namespace"
| "Narrowing"
| "New"
| "Next"
| "Not"
| "Nothing"
| "NotInheritable"
| "NotOverridable"
| "Object"
| "Of"
| "Off"
| "On"
| "Operator"
| "Option"
| "Optional"
| "Or"
| "Order"
| "OrElse"
| "Out"
| "Overloads"
| "Overridable"
| "Overrides"
| "ParamArray"
| "Partial"
| "Preserve"
| "Private"
| "Property"
| "Protected"
| "Public"
| "RaiseEvent"
| "ReadOnly"
| "ReDim"
| "Rem"
| "RemoveHandler"
| "Resume"
| "Return"
| "SByte"
| "Select"
| "Set"
| "Shadows"
| "Shared"
| "Short"
| "Single"
| "Skip"
| "Static"
| "Step"
| "Stop"
| "Strict"
| "String"
| "Structure"
| "Sub"
| "SyncLock"
| "Take"
| "Text"
| "Then"
| "Throw"
| "To"
| "True"
| "Try"
| "TryCast"
| "TypeOf"
| "UInteger"
| "ULong"
| "Unicode"
| "Until"
| "UShort"
| "Using"
| "Variant"
| "Wend"
| "When"
| "Where"
| "While"
| "Widening"
| "With"
| "WithEvents"
| "WriteOnly"
| "Xor"
| "GetXmlNamespace"
.

Literal =
	LiteralString |
	LiteralCharacter |
	LiteralInteger |
	LiteralDouble |
	LiteralSingle |
	LiteralDecimal |
	LiteralDate |
	"True" |
	"False" |
	"Nothing" |
	/* from InstanceExpression */
	"Me" |
	"MyBase" |
	"MyClass"
.

Statement =
	VariableDeclarationStatement
	| WithOrLockStatement
	| AddOrRemoveHandlerStatement
	| RaiseEventStatement
	| EXPECTEDCONFLICT("If") IfStatement /* prefer if-statement to if-expression */
	| SelectStatement
	| WhileStatement
	| DoLoopStatement
	| ForStatement
	| ErrorHandlingStatement
	| ThrowStatement
	| TryStatement
	| BranchStatement
	| ReDimStatement
	| EraseStatement
	| UsingStatement
	| InvocationStatement
.

VariableDeclarationStatement =
	( "Dim" | "Static" | "Const" )
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .)
	Identifier (. PopContext(); .) [ "?" ] { "(" [ Expression ] { "," [ Expression ] } ")" }
	{ ","
		(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .)
		Identifier (. PopContext(); .) [ "?" ] { "(" [ Expression ] { "," [ Expression ] } ")" }
	}
	[ "As" (. PushContext(Context.Type, la, t); .) ( NewExpression | TypeName ) (. PopContext(); .) ]
	[ "=" Expression ]
.

WithOrLockStatement =
	( "With" | "SyncLock" ) Expression StatementTerminatorAndBlock "End" ( "With" | "SyncLock" )
.

AddOrRemoveHandlerStatement =
	( "AddHandler" | "RemoveHandler" ) Expression "," Expression
.

RaiseEventStatement =
	"RaiseEvent" IdentifierOrKeyword [ "(" [ ArgumentList ] ")" ]
.

IfStatement =
    "If" Expression
    (    "Then"
        ( Statement { EXPECTEDCONFLICT(":") ":" [Statement] } [ EXPECTEDCONFLICT("Else") "Else" [Statement] { EXPECTEDCONFLICT(":") ":" [Statement] } ]
        | MultilineIfRemainder
        )
    |    MultilineIfRemainder
    )
.

MultilineIfRemainder =
    StatementTerminatorAndBlock
    {
        ("Else" [ "If" Expression [ "Then" ] ]
        | "ElseIf" Expression [ "Then" ]
        )
        StatementTerminatorAndBlock
    }
    "End" "If"
.

SelectStatement =
	"Select" [ "Case" ] Expression StatementTerminator
	{
		"Case" (
			"Else" |
			( [ "Is" ] ComparisonOperator SimpleExpressionWithSuffix | Expression )
				{ "," ( [ "Is" ] ComparisonOperator SimpleExpressionWithSuffix | Expression ) }
		)
		StatementTerminatorAndBlock
	}
	"End" "Select"
.

ComparisonOperator =
	"=" | "<>" | "<" | ">" (. wasNormalAttribute = false; .) | ">=" | "<="
.

WhileStatement =
	"While" Expression StatementTerminatorAndBlock "End" "While"
.

DoLoopStatement =
	"Do" ( DoTopLoopStatement | DoBottomLoopStatement )
.

DoTopLoopStatement =
	( "While" | "Until" ) Expression
	StatementTerminatorAndBlock
	"Loop"
.

DoBottomLoopStatement =
	StatementTerminatorAndBlock
	"Loop" [ ( "While" | "Until" ) Expression ]
.

ForStatement =
	"For" ( ForLoopStatement | ForEachLoopStatement )
.

ForLoopStatement =
	ForLoopVariable "=" Expression /* "To" is binary operator */ [ "Step" Expression ]
	StatementTerminatorAndBlock
	"Next" [ Expression { "," Expression } ]
.

ForEachLoopStatement =
	"Each" ForLoopVariable "In" Expression
	StatementTerminatorAndBlock
	"Next" [ Expression { "," Expression } ]
.

ForLoopVariable =
	(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) SimpleExpression (. PopContext(); .)
	[ "?" ] { ExpressionSuffix }
	[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
.

ErrorHandlingStatement =
	[ "On" ] "Error" ( Expression | "GoTo" ( LiteralInteger | Identifier ) | "Resume" "Next" )
	| "Resume" ( "Next" | LiteralInteger | Identifier )
.

ThrowStatement =
	"Throw" [ Expression ]
.

TryStatement =
	"Try"
	StatementTerminatorAndBlock
	{
		"Catch"
		[ (. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier (. PopContext(); .)
			[ "As" (. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) ]
		]
		[ "When" Expression ]
		StatementTerminatorAndBlock
	}
	[
		"Finally"
		StatementTerminatorAndBlock
	]
	"End" "Try"
.

BranchStatement =
	"GoTo" ( Identifier | LiteralInteger )
	| "Exit" ( "Do" | "For" | "While" | "Select" | "Sub" | "Function" | "Property" | "Try" )
	| "Continue" ( "Do" | "For" | "While" )
	| "Stop"
  /*| "End" HACK End-Statements has special handling in Block */
	| "Return" (. PushContext(Context.Expression, la, t); .) [ Expression ] (. PopContext(); .)
.

ReDimStatement =
	"ReDim"
	[ EXPECTEDCONFLICT("Preserve") "Preserve" ] /* Preserve is context-dependend keyword */
	Expression
.

EraseStatement =
	"Erase" Expression { "," Expression }
.

UsingVariable =
	[
		EXPECTEDCONFLICT("Where", "Until", "Unicode", "Text", "Take", "Skip", "Preserve",
						  "Order", "Off", "Out", "Key", "Join", "Into", "Infer", "Group", "From",
						  "Explicit", "Equals", "Distinct", "Descending", "Compare", "By",
						  "Binary", "Auto", "Assembly", "Ascending", "Ansi", "Aggregate", ident)
		(
			(. PushContext(Context.Identifier, la, t); .) (.OnEachPossiblePath: SetIdentifierExpected(la); .) Identifier
			// HACK: needs to be optional because Expression can start with Identifier too
			[ (. PopContext(); isAlreadyInExpr = true; .)
				( "As" [ EXPECTEDCONFLICT("Where", "UShort", "Until", "Unicode", "ULong", "UInteger", "Text", "Take",
		                 "String", "Skip", "Single", "Short", "SByte", "Preserve", "Out", "Order",
		                 "Off", "Object", "Long", "Key", "Join", "Into", "Integer", "Infer", "Group",
		                 "From", "Explicit", "Equals", "Double", "Distinct", "Descending", "Decimal",
		                 "Date", "Compare", "Char", "Byte", "By", "Boolean", "Binary", "Binary", "Auto",
		                 "Assembly", "Ascending", "Ansi", "Aggregate", ident)
						(. PushContext(Context.Type, la, t); .) TypeName (. PopContext(); .) "=" ]
				| "="
				| (.
					currentState = endOfStatementTerminatorAndBlock; /* leave this block */
					InformToken(t); /* process Identifier again*/
					/* for processing current token (la): go to the position after processing End */
					goto switchlbl;
				.)
				ANY /* never reached due to goto above: */
				/* this ANY is just so that Coco knows this branch isn't empty */
				)
			]
		)
	]
	Expression
	(. if (!isAlreadyInExpr) PopContext(); isAlreadyInExpr = false; .)
.

UsingStatement =
	"Using" UsingVariable { "," UsingVariable }
	StatementTerminatorAndBlock
	"End" "Using"
.

InvocationStatement =
	[ "Call" ] Expression
.

ArgumentList =
  (. activeArgument = 0; .) Expression { "," (. activeArgument++; .) [ Expression ] }
| (. activeArgument = 0; .)  "," (. activeArgument++; .) [ Expression ]  { "," (. activeArgument++; .) [ Expression ] }
.

/* This production handles pseudo keywords that are needed in the grammar */
Identifier =
	IdentifierForFieldDeclaration
	| "Custom"
.

IdentifierForFieldDeclaration =
	IdentifierForExpressionStart
	| "Aggregate"
	| "From"
.

IdentifierForExpressionStart = 
	IdentifierExceptOut
	| "Out"
.

IdentifierExceptOut =
	ident
	| "Ansi"
	| "Ascending"
	| "Assembly"
	| "Auto"
	| "Binary"
	| "By"
	| "Compare"
	| "Descending"
	| "Distinct"
	| "Equals"
	| "Explicit"
	| "Group"
	| "Infer"
	| "Into"
	| "Join"
	| "Key"
	| "Off"
	| "Order"
	| "Preserve"
	| "Skip"
	| "Take"
	| "Text"
	| "Unicode"
	| "Until"
	| "Where"
.

AccessModifier =
	"Public" |
	"Friend" |
	"Protected" |
	"Private"
.

TypeModifier =
	AccessModifier |
	"MustInherit" |
	"NotInheritable" |
	"Shadows" |
	"Partial"
.

MemberModifier =
	AccessModifier |
	"Shadows" |
	"Shared" |
	"Overridable" |
	"NotOverridable" |
	"NotInheritable" |
	"Overrides" |
	"Overloads" |
	"Partial" |
	"WithEvents" |
	"MustOverride" |
	"Widening" |
	"Narrowing" |
	"ReadOnly" |
	"WriteOnly" |
	"Default" |
	"Dim"
.

ParameterModifier =
	"ByVal" |
	"ByRef" |
	"Optional" |
	"ParamArray"
.

END ExpressionFinder .
